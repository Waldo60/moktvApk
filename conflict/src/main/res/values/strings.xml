<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="conflict">滑动冲突</string>

    <string name="app_name">滑动冲突解决</string>
    <string name="inner_intercept">内部拦截</string>
    <string name="outer_intercept">外部拦截</string>
    <string name="viewpager_nested_horizontal">Viewpager水平滚动嵌套</string>
    <string name="touch_event_demo">事件分发原理</string>
    <string name="webview_conflict">Webview滑动冲突</string>
    <string name="two_scroll">二级联动</string>
    <string name="nested_scroll">二级嵌套滑动</string>
    <string name="hello_blank_fragment">贪心算法是一种在每一步中都采取当前状态最好或最优的选择，从而希望导致结果是全局最好或最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法可以解决一些最优化问题，如求途中的最小生成树，求哈夫曼编码等，但对于工程和生活中的问题，贪心算法一般不能得到我们所要求的答案。 一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。 由于贪心发的高效性以及其所求得的答案比较接近最优结果，贪心算法也可用于辅助算法或者直接解决一些要求结果不特别精确的问题。

问题能够分解成子问题，子问题的最优解能递推到最终问题的最优解。 这种子问题最优解称为最优子结构。
    贪心算法是一种在每一步中都采取当前状态最好或最优的选择，从而希望导致结果是全局最好或最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法可以解决一些最优化问题，如求途中的最小生成树，求哈夫曼编码等，但对于工程和生活中的问题，贪心算法一般不能得到我们所要求的答案。 一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。 由于贪心发的高效性以及其所求得的答案比较接近最优结果，贪心算法也可用于辅助算法或者直接解决一些要求结果不特别精确的问题。

问题能够分解成子问题，子问题的最优解能递推到最终问题的最优解。 这种子问题最优解称为最优子结构。
    贪心算法是一种在每一步中都采取当前状态最好或最优的选择，从而希望导致结果是全局最好或最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法可以解决一些最优化问题，如求途中的最小生成树，求哈夫曼编码等，但对于工程和生活中的问题，贪心算法一般不能得到我们所要求的答案。 一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。 由于贪心发的高效性以及其所求得的答案比较接近最优结果，贪心算法也可用于辅助算法或者直接解决一些要求结果不特别精确的问题。

问题能够分解成子问题，子问题的最优解能递推到最终问题的最优解。 这种子问题最优解称为最优子结构。
    贪心算法是一种在每一步中都采取当前状态最好或最优的选择，从而希望导致结果是全局最好或最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法可以解决一些最优化问题，如求途中的最小生成树，求哈夫曼编码等，但对于工程和生活中的问题，贪心算法一般不能得到我们所要求的答案。 一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。 由于贪心发的高效性以及其所求得的答案比较接近最优结果，贪心算法也可用于辅助算法或者直接解决一些要求结果不特别精确的问题。

问题能够分解成子问题，子问题的最优解能递推到最终问题的最优解。 这种子问题最优解称为最优子结构。</string>

</resources>