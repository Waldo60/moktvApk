## 声明

每个名字，每个表达式都有一个类型，以确定可以对它们执行的操作。

一个名字能够在C++程序里使用之前必须首先声明。
也就是说，必须首先刻画清楚它的类型，以通知编译器它所用的是那一类的实体。

变量声明用于说明变量的属性，而变量定义除此之外还将引起存储的分配。

每个命名实体必须恰好有一个定义，但是它们可以有多个声明。
一个实体的所有声明必须在所引用的类型上完全一致。

任何描述了初始值的声明都是一个定义。

### 结构

一个声明由四部分组成：一个可选的描述符，一个基础类型，一个声明符以及一个可选的初始化表达式。

描述符是一个开始关键字，如virtual和extern，它们说明了被声明事物的非类型属性。

声明符由一个名字和若干可选的声明运算符组成。常见的声明远算符是

- \*        指针
- \* const  常量指针
- &         饮用
- []        数组
- ()        函数

\*、[]、()被设计为模仿它们在表达式里的使用方式。这样\*是前缀，而[]和()是后缀。
而且后缀的声明运算符比前缀的声明运算符约束力更强。
（参考[复杂声明](https://github.com/donfyy/Android/blob/master/ndk/c.md#%E4%BE%8B1%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E)）

另外，声明中可以包含一个由逗号分隔的声明符列表。

### 名字

### 作用域

一个声明将一个名字引进一个作用域。名字的作用域指的是程序中可以使用该名字的部分。

外部变量或函数的作用域从声明它的地方开始，到其所在文件的末尾结束。

对于函数里声明的自动变量，其作用域从声明它的地方开始，到其所在块的末尾结束。一个块就是由{}围起的一段代码。

一个块里声明的名字可以遮蔽在其外围块里声明的名字或者全局的名字。

一个名字的作用域从它被声明的那点开始，也就是在声明符结束之后，初始式开始之前可用。
这意味一个名字甚至可以用于描述它自己的初始值。

```c++
int x;
void f1() {
    int x = x; // 不当：用x（未初始化）自己的值初始化x
}
```

这样做并不非法，只是荒谬。

### 初始化

如果为一个对象提供了初始式，这个初始式将确定对象的初始值。
如果没有提供初始式，则全局的、命名空间的、局部静态的对象将被自动初始化为适当类型的0。
而自动对象和堆对象不会用默认值初始化。

数组和结构的成员，是根据数组和结构是否为静态来确定是否默认地进行初始化。
用户定义类型可以有自定义的默认初始化方式。

更复杂的对象需要以多于一个的值作为初始式。
数组和结构的C风格初始化采用的是 { 和 } 括起的初始化列表描述。
带有构造函数的用户定义类型采用的是函数风格的参数表形式。

**在声明中写一对空的()总是意味着"函数"。**

### 对象和左值

我们可以分配和使用没有名字的变量，而且可能对一个看起来很奇怪的表达式赋值(例如、\*p\[a = 10\] = 10)。
因此对一个名字的某种需要就是它应该表示"存储器里的某些东西"。这也就是最简单最基本的对象概念。
这样，一个**对象**就是存储中的一片连续的区域。**左值**就是引用某个对象的表达式。
**左值**原本是想说"某个可以放在赋值左边的东西"。然而并不是每个**左值**都可以放在赋值的左边，
**左值**也可以是引用了某个常量。没有被声明为常量的**左值**常常被称为**可修改的左值**。
不要将对象这种简单和低级的概念和类对象以及多态类型的对象概念混淆了。

除非程序员另有描述（静态变量、静态对象），在一个函数里声明的对象都在其定义被遇到处开始建立，在它的名字离开作用域的时候被销毁。这种对象被称为自动对象。在全局和命名空间作用域里的对象，以及在函数和类里声明为static的对象只建立一次，它们一直生存到程序结束。这种对象被称为静态对象。数组成员、非静态结构和类的成员的生命周期由它们作为其部分的那些对象决定。

通过new和delete运算符，可以建立生命周期可以直接控制的对象。

### typedef



## 引用

一个引用就是某对象的另一名字。引用主要是为了描述函数的参数和返回值，特别是运算符的重载。**X**& 记为到**X**的引用。

- 引用必须初始化，是为了确保一个引用总是某个对象的名字。
- 引用的值在初始化之后就不能改变了，它总是引用初始化时所指的那个对象
- 没有能操作引用的运算符

引用的一种最明显的实现方式是作为常量指针(*const)，在每次使用它时都自动地做间接访问。

可以通过引用来描述一个函数参数，以使该函数能够改变传递来的变量的值。

```c++
    void increment(int &aa) { aa++; }

    void f() {
      	int x = 1;
      	increment(x);	// x = 2
    }
```

参数传递的语义通过对应的初始化定义，所以，在调用时，increment的参数aa将变成x的另一个名字。

```c++
    int a = 10;
    // type & name = var;
    int &b = a; //b就是一个引用,请不要用C的语法是思考
    //就是给a变量取了一个别名
    printf("b:%d\n", b); // 10
    printf("a:%d\n", a); // 10

    b = 100;
    printf("b:%d\n", b); // 100
    printf("a:%d\n", a); // 100
    // type * const 指针常量
    // int &c;//会报错的，普通的引用必须要依附某个变量，必须初始化
    int c = 20;
    b = c; // 这里是给b所指的的对象a赋值，并不是让b引用c
    c = 30;
    printf("b:%d\n", b); // 20
    printf("a:%d\n", a); // 20
    printf("c:%d\n", c); // 30
```



## 类

就是一个用户定义类型。

### 成员函数

在一个类里声明的函数被称做成员函数。这种函数只能通过适当类型的特定变量，采用标准的结构成员的访问语法形式调用。

### 访问控制

对私有成员的保护依靠的是对于使用类成员名字的限制。可以通过地址操作和显式的类型转换绕过这些限制。不过，这些方式当然是作弊行为。C++的保护只是为了避免无意的失误，而不是为了防止精心策划的计谋。只有硬件才可能防止对通用语言的恶意使用。当然，即使是利用了硬件，想在现实的系统里把这件事情做好也非常困难。

### 构造函数

构造函数的目的是去完成对象的初始化，具有与类同样的名字。

### 静态成员

如果一个变量是类的一部分，而不是类的各个对象的一部分，它就被称为一个static成员。

静态成员，包括函数和数据成员，都必须在类外部另行定义。

### 常量成员函数

在参数列表后有const关键字的成员函数，被称为常量成员函数，const指出该函数不会修改对象的状态。

### 自引用（this）

每个成员函数都知道它是为了哪个对象而调用的，因此可以显示的引用该对象。

在成员函数里，表达式*this引用的就是这个函数这次调用所针对的那个对象。

this是一个指针，指向成员函数被调用时所针对的那个对象。this不是一个常规变量，不能取得this的地址或者给它赋值。

#### 物理的和逻辑的常量性

一个成员函数在逻辑上是const，但是它却仍然需要改变某个成员的值。对用户而言，这个函数看似没有改变对象的状态，然而它却可能更新了，某些用户不能直接访问的细节。这种常被称为逻辑的常量性。

可以使用const_cast<T>(var)强制去掉const，但是要保证var这个对象本身或者它指向的对象是可以修改的。

```c++
    const Test2 t(1);
```

t被定义为const，具体实现很有可能为保护它的值不被破坏而使用某种特殊形式的存储。

#### 可变的-mutable

存储描述符mutable特别说明这个成员需要以一种允许更新的方式存储-即使它是某个const对象的成员。

### 结构和类

一个struct也就是一个类，但是其成员默认为公用的。

除名字不同之外，下面两个声明完全等价：

```c++
    class Date1
    {
        int d, m, y;

    public:
        Date1(int, int, int);
        void add_year(int);
    };
    struct Date2
    {
    private:
        int d, m, y;

    public:
        Date2(int, int, int);
        void add_year();
    };
```

通常将struct用于所有成员都是公用的那些类。作者认为这些类“并不是完整的类型，不过是个数据结构”。

### 在类内部的函数定义

如果一个函数是在类定义的内部定义的-而不仅仅是在这里声明-它就被作为一个inline成员函数。也就是说在类内部定义的成员函数，应该是小的，频繁使用的成员函数。

### 对象

#### 析构函数

构造函数完成对象的初始化，它建立起一种成员函数将在其中操作的环境。有时建立这样一个环境需要申请某些资源，例如一个文件，一个锁，或者一些存储，这些资源在使用之后必须释放。这样，有些类里就需要有些函数，并需要保证它将在每个对象被销毁之前得以调用。按照习惯，这个函数被称为析构函数，它通常完成清理和释放资源的工作。当一个自动变量离开其作用域时，当一个位于自由存储的对象被删除时，还有其他类似情况中，析构函数都将被隐式调用。只有在非常特殊的情况下，用户才需要去显式地调用析构函数。

#### 默认构造函数

默认构造函数就是调用时不用提供参数的构造函数。如果用户自己声明了一个默认构造函数，那么就会去使用它；否则，如果有必要而且用户没有声明其他的构造函数，那么编译器就会设法生成一个。编译器将隐式地为类类型的成员和它的基类调用有关的默认构造函数。

```c++
    struct Tests
    {
        int i;
        int vi[10];
        Test2 t1;
        Test2 t2[10]; // 这里与Java不同，Java这么写表示t2是一个引用数组，c++这里是对象数组
    };

    void f()
    {
        Tests tt;
    }

```

tt将被用一个生成出来的默认构造函数初始化，该函数为tt.t1和tt.t2的每个成员调用Test2()。另一方面，它不会去初始化tt.i和tt.vi因为它们不是类类型的对象。对于类类型和内部类型的区别对待是为了与C的兼容性，也是为避免运行时的额外开销。

由于const和引用必须进行初始化，包含const或引用成员的类就不能进行默认构造，除非程序员显式地提供了默认构造函数。例如，

```c++
    struct X
    {
        const int a;
        const int &r;
    };

    void f()
    {
        // X x; // 错误：X无默认构造函数
    }
```

默认构造函数也可以显式调用。内部类型同样也有默认构造函数。

#### 构造和析构

现在考虑奖励对象的各种不同方式，以及它们后来怎样销毁。一个对象可以通过如下方式建立：

- 一个命名的自动对象，每次程序遇到它的声明时建立，每次程序离开它所在的块时销毁。
- 一个自由存储对象，通过new运算符建立，通过delete运算符销毁。
- 一个非静态成员对象，作为另一个类对象的成员，在它作为成员的那个对象建立或销毁时，它也随之建立或销毁。
- 一个数组元素，在它作为元素的那个数组建立或销毁时，它也随之建立或销毁。
- 一个局部静态对象，在程序第一次遇到它的声明时建立一次，在程序终止时销毁一次。
- 一个全局对象，命名空间的对象，类的静态对象，它们只在“程序开始时”建立一次，在程序终止时销毁一次。
- 一个临时对象，作为表达式求值的一部分被建立，在它所出现的那个完整表达式的最后被销毁。
- 一个在分配操作中，由所提供的参数控制，在通过用户提供的函数获得的存储里放置的对象。
- 一个union成员，它不能有构造函数和析构函数。

### 对象声明、初始化、赋值

```c++
    // Test2 t = (1, 2, 3);
    // Test2 t = 9;
    // Test2 t(1);
    // Test2 t{1};
    // Test2 t = {1};
    // Test2 t = Test2(1);
    Test2 t1(1);
    Test2 t2(2);
    t1.print();    // 1
    t1 = t2;       // 对象之间赋值，没有新建对象，这里与Java不同
    t1.print();    // 2
    Test2 t3 = t1; // 调用拷贝构造函数 对象初始化
    Test2 t4(t1);  // 调用拷贝构造函数 对象初始化
```

### 作为函数参数的对象

```c++
    void takingObject(Test2 t)
    {
        cout << t.getA() << endl;
    }
    
    Test2 t(1);
    takingObject(t); // 调用拷贝构造函数

```

### 作为返回值的对象

```c++
    Test2 returnObject()
    {
        Test2 t(4, 5);
        return t;
    }

    // returnObject();
    Test2 t1 = returnObject(); //初始化 t1, 创建一个匿名对象，(扶正)从匿名转成了有名字了 t1
    t1.print(); // 注意：这里只创建了1个对象，t1就是返回的对象。

    Test2 t2(1, 2);
    t2 = returnObject(); // 返回的对象在其值赋给t2后立即被销毁(在t2.print()之前被销毁)
    t2.print();
```

### 浅拷贝与深拷贝

拷贝构造函数与赋值运算符的默认实现是浅拷贝，所以如果某个类内部分配了堆内存，该类需要重写拷贝构造函数和赋值运算符以获得期望的行为。

```c++
    class Test3
    {
    public:
        Test3();
        Test3(const char *arg);
        Test3(const Test3 &t);
        ~Test3();
        Test3 &operator=(Test3 &t);
        void print();
    
    private:
        int id = g_id++;
        char *p;
    };
    Test3::Test3()
    {
        p = (char *)malloc(100);
        strcpy(p, "steady!");
        cout << "Test3(): id = " << id << endl;
    }
    Test3::Test3(const char *arg)
    {
        p = (char *)malloc(100);
        strcpy(p, arg);
        cout << "Test3(const char*): id = " << id << endl;
    }
    Test3::Test3(const Test3 &t)
    {
        p = (char *)malloc(100);
        strcpy(p, t.p);
        cout << "Test3(const Test3 &): id = " << id << endl;
        // p = t.p; Oops! t1和t2指向了同一块堆内存，t1被析构后，该堆内存被释放，但t2仍在使用该堆内存
    }
    Test3::~Test3()
    {
        if (p != NULL)
            free(p);
        cout << "~Test3() :id = " << id << endl;
    }
    Test3 &Test3::operator=(Test3 &t)
    {
        strcpy(p, t.p);
        return *this;
    }
    void Test3::print()
    {
        cout << "id: " << id << " p: " << p << endl;
    }

    // 赋值运算符以及拷贝构造函数的默认实现是浅拷贝，
    // 如果类内部分配了堆内存，则该类需要重写析构函数，拷贝构造函数，以及赋值运算符等。
    // 构造函数的调用顺序：t1 -> t2 -> t3
    // 析构函数的调用顺序：t1 <- t2 <- t3
    void example05()
    {
        Test3 t1("t1");
        t1.print();
        Test3 t2 = t1;
        t2.print();
        Test3 t3("t3");
        t3.print();
        t3 = t1;
        t3.print();
    }

```

