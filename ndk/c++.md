## 声明

每个名字，每个表达式都有一个类型，以确定可以对它们执行的操作。

一个名字能够在C++程序里使用之前必须首先声明。
也就是说，必须首先刻画清楚它的类型，以通知编译器它所用的是那一类的实体。

变量声明用于说明变量的属性，而变量定义除此之外还将引起存储的分配。

每个命名实体必须恰好有一个定义，但是它们可以有多个声明。
一个实体的所有声明必须在所引用的类型上完全一致。

任何描述了初始值的声明都是一个定义。

### 结构

一个声明由四部分组成：一个可选的描述符，一个基础类型，一个声明符以及一个可选的初始化表达式。

描述符是一个开始关键字，如virtual和extern，它们说明了被声明事物的非类型属性。

声明符由一个名字和若干可选的声明运算符组成。常见的声明远算符是

- \*        指针
- \* const  常量指针
- &         饮用
- []        数组
- ()        函数

\*、[]、()被设计为模仿它们在表达式里的使用方式。这样\*是前缀，而[]和()是后缀。
而且后缀的声明运算符比前缀的声明运算符约束力更强。
（参考[复杂声明](https://github.com/donfyy/Android/blob/master/ndk/c.md#%E4%BE%8B1%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E)）

另外，声明中可以包含一个由逗号分隔的声明符列表。

### 名字

### 作用域

一个声明将一个名字引进一个作用域。名字的作用域指的是程序中可以使用该名字的部分。

外部变量或函数的作用域从声明它的地方开始，到其所在文件的末尾结束。

对于函数里声明的自动变量，其作用域从声明它的地方开始，到其所在块的末尾结束。一个块就是由{}围起的一段代码。

一个块里声明的名字可以遮蔽在其外围块里声明的名字或者全局的名字。

一个名字的作用域从它被声明的那点开始，也就是在声明符结束之后，初始式开始之前可用。
这意味一个名字甚至可以用于描述它自己的初始值。

```c++
int x;
void f1() {
    int x = x; // 不当：用x（未初始化）自己的值初始化x
}
```

这样做并不非法，只是荒谬。

### 初始化

如果为一个对象提供了初始式，这个初始式将确定对象的初始值。
如果没有提供初始式，则全局的、命名空间的、局部静态的对象将被自动初始化为适当类型的0。
而自动对象和堆对象不会用默认值初始化。

数组和结构的成员，是根据数组和结构是否为静态来确定是否默认地进行初始化。
用户定义类型可以有自定义的默认初始化方式。

更复杂的对象需要以多于一个的值作为初始式。
数组和结构的C风格初始化采用的是 { 和 } 括起的初始化列表描述。
带有构造函数的用户定义类型采用的是函数风格的参数表形式。

**在声明中写一对空的()总是意味着"函数"。**

### 对象和左值

我们可以分配和使用没有名字的变量，而且可能对一个看起来很奇怪的表达式赋值(例如、\*p\[a = 10\] = 10)。
因此对一个名字的某种需要就是它应该表示"存储器里的某些东西"。这也就是最简单最基本的对象概念。
这样，一个**对象**就是存储中的一片连续的区域。**左值**就是引用某个对象的表达式。
**左值**原本是想说"某个可以放在赋值左边的东西"。然而并不是每个**左值**都可以放在赋值的左边，
**左值**也可以是引用了某个常量。没有被声明为常量的**左值**常常被称为**可修改的左值**。
不要将对象这种简单和低级的概念和类对象以及多态类型的对象概念混淆了。

除非程序员另有描述（静态变量、静态对象），在一个函数里声明的对象都在其定义被遇到处开始建立，在它的名字离开作用域的时候被销毁。这种对象被称为自动对象。在全局和命名空间作用域里的对象，以及在函数和类里声明为static的对象只建立一次，它们一直生存到程序结束。这种对象被称为静态对象。数组成员、非静态结构和类的成员的生命周期由它们作为其部分的那些对象决定。

通过new和delete运算符，可以建立生命周期可以直接控制的对象。

### typedef



## 引用

一个引用就是某对象的另一名字。引用主要是为了描述函数的参数和返回值，特别是运算符的重载。**X**& 记为到**X**的引用。

- 引用必须初始化，是为了确保一个引用总是某个对象的名字。
- 引用的值在初始化之后就不能改变了，它总是引用初始化时所指的那个对象
- 没有能操作引用的运算符

引用的一种最明显的实现方式是作为常量指针(*const)，在每次使用它时都自动地做间接访问。

可以通过引用来描述一个函数参数，以使该函数能够改变传递来的变量的值。

```c++
    void increment(int &aa) { aa++; }

    void f() {
      	int x = 1;
      	increment(x);	// x = 2
    }
```

参数传递的语义通过对应的初始化定义，所以，在调用时，increment的参数aa将变成x的另一个名字。

```c++
    int a = 10;
    // type & name = var;
    int &b = a; //b就是一个引用,请不要用C的语法是思考
    //就是给a变量取了一个别名
    printf("b:%d\n", b); // 10
    printf("a:%d\n", a); // 10

    b = 100;
    printf("b:%d\n", b); // 100
    printf("a:%d\n", a); // 100
    // type * const 指针常量
    // int &c;//会报错的，普通的引用必须要依附某个变量，必须初始化
    int c = 20;
    b = c; // 这里是给b所指的的对象a赋值，并不是让b引用c
    c = 30;
    printf("b:%d\n", b); // 20
    printf("a:%d\n", a); // 20
    printf("c:%d\n", c); // 30
```

